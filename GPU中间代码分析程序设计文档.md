# GPU中间代码分析程序

### 第三部分

​	第三部分的主要工作就是在一个已经完全没有CUDA痕迹的代码中，我们把我们需要提前知道值的变量的相关代码保留下来，这是一部代码优化的工作。

​	因为第三部分的程序逻辑比较复杂，并且根据我们在书写第一部分和第二部分所攒下的教训，我们引入了新的特性。

#### 状态栈

​	程序栈可以帮助我们在回溯到之前的状态。他拥有下面的弹栈和压栈的规则，如果碰到if，while，for，do就分别进入IF，WHILE，FOR，DO，这么几个状态，根据大括号嵌套层级，以及右括号的位置，我们可以知道各个状态的退出位置。IF状态不能进行单纯的退出，在匹配到右大括号的时候还要时刻注意右边是不是还有ELSE。ELSE的弹栈必须和与其配套的IF一起进行。WHILE和IF使用的是同一个状态，因为从语法的构成来说他们几乎一致。FOR和IF的状态也很想，但是我们要注意FOR里面形参的变量相当多，如果特别是哨兵变量（i），这个几乎会在所有的FOR循环的形参中出现，如果我们把这个变量加入关键变量，那么就意味着这个程序中很多无关的循环都会卷入其中，要解决这种问题的主要方法就是去着力寻找DU路径，在我们找到DU路径的识别方法之前，我们先把这些循环全部卷入其中好了。

​	在看DO，这个状态没有形参，他需要和一个和和自己同嵌套等级的WHILE同时出栈。

​	我们仅仅记录状态名是不够的，我们还需要在栈中还需要存其他东西。首先我们需要存储整个头部的行号，对于if来说就是if和if的形参所占有的行号范围，具体的原因的关键变量的勾选有关系。还有就是这个状态的嵌套等级，这个嵌套等级的作用就是为了探求退出状态的时机。当我们找到一个右大括号，并且发现当扣除嵌套等级之后新的嵌套等级和栈顶所对应的嵌套等级一样的时候，我们就可以按照一定的要求退出这个状态并且进行其他操作了。

#### 变量勾选

​	第三部分的代码优化的核心工作就是进行关键变量的相关行的勾选。在不同的状态下，我们需要不一样的变量的勾选策略。

​	关键变量的主要出现在两个地方一个就是在括号里面当形参，还有一种就是在大括号中。

​	对于出现在括号里面的，我们需要保留整个这一行，这里可能有两种情况，一种就是普通的函数调用，因为我们在前几次扫描的时候就搞定了代码的格式，主要就是右大括号，左大括号，分号之后要有回车，用户自己的回车我们要全部去掉。

​	