# GPU中间代码分析程序

### 第一部分

​	我们的第一次扫描应对的是整个GPU的完整中间代码。这次扫描一共就一次，主要有这么几个工作：

1. 去除所有运行库的代码，只保留用户写的代码。
2. 获取内核函数的名称，方面在第二部分中扫描中删除用户写的内核函数的实现。

#### 注释

​	在GPU中间代码中，每一行代码上面都有注释，这个注释标明了这一行代码的来源。

​	第一次扫描的关键部分就是处理注释问题。按照读懂编译器给的注释就可以把用户写的代码筛选出来。我们定位所有的注释。处理好下面两种：

1. `# 54 "/usr/local/cuda-6.5/include/device_types.h" 2 3`
2. `# 45 "../src/Test2.cu"`

​	前面一种是系统运行库的，下面一种是用户自己写的。系统运行库一般有这么几个默认位置：

1. /usr/include
2. /usr/lib
3. /usr/local

​	一般情况下我们就使用默认位置进行匹配，当然我们还会加入一些可配置项，用户可以添加自定义的位置，以此来为分析程序做一些补充。

​	所以说我们要做的工作就是如果我们发现了一行注释里面的路径是系统运行库，那么我们就忽略下一行代码。这样子就做到了保留用户所写的代码。

#### 内核函数

​	因为在保留了用户所写的代码之后，我们需要去除这个代码中所有与CUDA相关的东西，所以我们需要提前获知这个内核函数的名字。在GPU中间代码中，内核函数的发射有一个很明显的模式（在这个例子中，bitreverse就是一个内核函数的名字）：

`(cudaConfigureCall(1, WORK_SIZE, WORK_SIZE * sizeof(int))) ? (void)0 : (bitreverse)(d);`

​	当我们匹配到cudaConfigureCall的时候，我们就将自动机转入一个特殊状态。这个状态将集中寻找内核函数的名字。找到之后，状态退出。

#### 格式整理

​	因为我们编写的词法分析程序是以行单位进行代码的筛选的，所以我们要尤其注意对于格式的整理。在这次扫描中我们将忽略用户写的所有回车换行，并且我们将自己添加回车，回车出现的位置主要是大括号后，分号后。此外为了方便后面的工作，我们在左括号的后面添加一个空格。

### 第二部分

​	第二部分的工作就是去除所有和CUDA有关系的东西。第一部分我们得到的代码经过第二部分处理之后我们可以获得一段完全没有CUDA与GPU影子的代码。

#### 去除CUDA相关函数

​	这一步我们除了去除CUDA的相关函数，还有一些其他工作。首先是把关键函数找出来，然后关键函数中我们有关键的变量（线程、线程块、共享内存等）。我们把在这个关键函数的位置插入一个IO语句，使得我们在运行裁剪之后的代码的时候程序可以在这个位置吧关键变量的值打印出来，或者写到文件里，这样子就得到了我们代码分析最终想要的东西。

​	CUDA相关函数的去除部分主要分为3个工作。

​	首先是内核函数，这个函数的函数名我们在第一部分的时候已经得到。内核函数是用户自己写的函数，而不是CUDA运行库的函数，所以我们不仅需要去掉的是函数的调用，而且还有函数的声明和实现。

​	然后就是CUDA关键函数，这类函数包括cudaConfigureCall，还有内存申请、内存拷贝。这类函数我们需要进入专门的状态进行形参分析。把我们关注的形参中的变量找到，并且使用一个IO语句在原地打印或者写文件。关于CUDA关键函数其他的一些处理和下一段CUDA其他函数一样。

​	最后就是CUDA的其他函数，这些函数全部删除。但是因为一些函数可能出现在IF、while等结构中，如果这些函数出现在if以及while之类函数的分支条件和循环条件中，那么整个分支和循环也要删除。

#### 去除CUDA相关变量

​	这个工作主要就是删除CUDA的变量，需要两次扫描，我们使用CUDA的数据类型来定位。我们在第一遍扫描中定位CUDA的数据类型，并且找到后面那个变量的函数名，记录变量名。

​	然后我们进入第二遍扫描，这个时候我们找到有这个变量的行，并且把这一行删除即可。这里也涉及上文所说的分支循环条件的问题。不重复说明。

​	去除CUDA的相关变量，只记下变量名是不够的，我们还要记下这个变量的所在的生命周期。主要是为了应对下面这种情况：

`int a = 1;`

`{`

        `cudaError a = 1;`

`}`

​	这里我们可以看出，其实虽然外面的int类型的变量也叫a，但是此a非彼a。所以我们引入“嵌套等级”的概念。

#### 嵌套等级

​	嵌套等级是一个数组，这个数组长度决定了我们可以匹配嵌套级数，一个变量被越多的大括号包含，那么嵌套的级数就越多（在实际实现中，我简化了，把嵌套等级定为一个长度只有1的数组）。

​	为了方便举例，我们将嵌套等级这个数组的长度设为3，即最多可以区分3个大括号套在一起的情况。起始状态{0,0,0}。

​	一个变量的这个数组是这样形成的，读头在扫描文件的时候当遇到一个	大括号{，那么这个时候数组的第一位就是1，这个我们设计一个参数index，这个index要自增。所以说这个时候数组index对应位加一就是{1,0,0}，index就是1 。表示下一次要更改的数组第二位。然后如果这个时候又碰到一个大括号那么这个时候index所在的那一位就要加一，{1,1,0}。在这之后，如果这个时候遇到一个左括号，那么就执行index自减。综上，遇到左大括号就执行两个操作，右大括号就一个操作。

​	我们就可以定位每一个变量的声明周期了，我们只删除生命周期被包含在我们所记录的嵌套等级之内的名字相同的变量。

#### 分支与循环的嵌套

​	我们知道if、while、do、for、else等东西是可以嵌套在一起的，删除的过程也是级联在一起的，因为我在写这一部分的时候当时并没有想到我们可以设计“状态栈“来解决这个问题，所以实现的办法比较麻烦，但是实际上还是可以归结到状态栈去解决。

### 第三部分

​	第三部分的主要工作就是在一个已经完全没有CUDA痕迹的代码中，我们把我们需要提前知道值的变量的相关代码保留下来，这是一部代码优化的工作。

​	因为第三部分的程序逻辑比较复杂，并且根据我们在书写第一部分和第二部分所攒下的教训，我们引入了新的特性。

#### 字符串的处理

​	在程序中有些单词会出现在字符串中，这些字符串中的内容对于程序的逻辑来说本质上没有任何意义，但是会干扰我们的判断。我们使用特定的状态来处理。

​	当我们匹配到一个双引号的时候（这里不包括转义字符后面的双引号，我们使用更高等级的匹配覆盖，如果我们之前匹配到一个单引号，并且这个单引号还没有闭合，那么也忽视掉），自动机进入MARKS状态，知道双引号闭合之后才退出。

#### 状态栈

​	程序栈可以帮助我们在回溯到之前的状态。他拥有下面的弹栈和压栈的规则，如果碰到if，while，for，do就分别进入IF，WHILE，FOR，DO，这么几个状态，根据大括号嵌套层级，以及右括号的位置，我们可以知道各个状态的退出位置。IF状态不能进行单纯的退出，在匹配到右大括号的时候还要时刻注意右边是不是还有ELSE。ELSE的弹栈必须和与其配套的IF一起进行。WHILE和IF使用的是同一个状态，因为从语法的构成来说他们几乎一致。FOR和IF的状态也很想，但是我们要注意FOR里面形参的变量相当多，如果特别是哨兵变量（i），这个几乎会在所有的FOR循环的形参中出现，如果我们把这个变量加入关键变量，那么就意味着这个程序中很多无关的循环都会卷入其中，要解决这种问题的主要方法就是去着力寻找DU路径，在我们找到DU路径的识别方法之前，我们先把这些循环全部卷入其中好了。

​	在看DO，这个状态没有形参，他需要和一个和和自己同嵌套等级的WHILE同时出栈。也就是说如果WHILE状态在形参之后之间匹配到了分号，那么WHILE就要和DO一起弹栈。

​	我们仅仅记录状态名是不够的，我们还需要在栈中还需要存其他东西。首先我们需要存储整个头部的行号，对于if来说就是if和if的形参所占有的行号范围，具体的原因的关键变量的勾选有关系。还有就是这个状态的嵌套等级，这个嵌套等级的作用就是为了探求退出状态的时机。当我们找到一个右大括号，并且发现当扣除嵌套等级之后新的嵌套等级和栈顶所对应的嵌套等级一样的时候，我们就可以按照一定的要求退出这个状态并且进行其他操作了。

#### 关键行勾选

​	第三部分的代码优化的核心工作就是进行关键变量的相关行的勾选。在不同的状态下，我们需要不一样的变量的勾选策略。

​	关键变量的主要出现在两个地方一个就是在括号里面当形参，还有一种就是在大括号中。

​	对于出现在括号里面的，我们需要保留整个这一行，这里可能有两种情况，一种就是普通的函数调用，因为我们在前几次扫描的时候就搞定了代码的格式，主要就是右大括号，左大括号，分号之后要有回车，用户自己的回车我们要全部去掉。所以说一个函数的调用将会出现在同一行，也就是说保留了这一行，也就能保留整个函数调用。表达式和函数调用有异曲同工之妙。

​	除了函数调用，还有IF、WHILE、FOR。这些也都是有形参的，如果发现在形参中发现了我们需要的关键变量。那么我们就需要保留整个状态的头部，这个头部就是我们在函数栈中保留的头部行号。其实如果在IF、WHILE、FOR的函数体中发现了关键变量，那么整个头部的行号也要加入到保留行中。所以说IF（不带ELSE的），WHILE（不带DO的），FOR。属于一类情况。

​	还有就是ELSE，因为这个东西是和IF一块弹栈的。所以我们如果在ELSE状态下发现了关键变量，那么我们要做的就是把ELSE和之前的IF同时弹栈，并且IF和ELSE的头部行号全部存起来。

​	还有就是DO这个状态，如果在WHILE的形参中发现了关键变量，那么我们就需要不仅仅保留DO状态的头部，也要保留WHILE状态的头部。

​	对于形参中发现关键变量的情况，我们需要的就是在形参部分完结之后把整个头部记入关键行号。

​	以上就是对于关键行号处理的相关内容。在我们知道了一批关建行之后我们还需要一批关键变量，我们需要对关键行进行扫描，找出新的关键变量，然后通过关键变量找出新的关键行即可。

​	现在还有勾选的问题，因为我们需要一个变量来记录保存IF、WHILE等头部的情况。这就需要我们在状态栈中再加一位，如果如果在一个状态下出现了关键变量，那么我们就要记录这个关键变量的行号，然后把当前状态和在当前状态栈底的状态的头部保留标示位全部由0换成1。包括自身，将自身行号存起来，放到一个数组里面。我们在弹栈的时候我们需要看一看这个栈的节点的那个头部保留标志位是不是1，如果是1，那么我们就需要把这个节点对应的头部行号放到一个数组中。

​	还有一个是比较特殊的问题，那就是DO...WHILE的问题，DO后面的那个WHILE在看是不是需要保留头部行的时候，不仅要看WHILE，还要看DO，如果DO那里要保留头部，那么WHILE也要保留头部。



#### 通过关建行获取新的关键变量

​	经过一段努力，我们使用了初步的关键变量获取了关建行，现在我们需要在这些关建行上进行扫描，以获取新的关键变量，反复进行两个过程，直到我们想要保留的行号不再增加。这个步骤的做法还是比较简单的。我们会获取的行号长这样：

![resultFileIMG](pic/resultFileIMG.png)	在Java外壳程序中，我们做的工作就是将相同的行号合并，这个过程主要的想法是先定为这样：

​	我打算使用Java的HashSet来尽可能保证合并效率，Java程序每次从文件中读一个数字，并且把这个数字放到JavaSet中。然后我们要做的工作就是，将JavaSet中的所有数字使用一次快速排序（应该先要把HashSet变成ArrayList，和人认为最快的办法就是使用Hashset，直接放到ArrayList的构造函数中）。然后放到这一次扫描中（获取关键变量是在一次新的扫描中的）。

​	然后我们对CUDA程序的文本进行再一次的扫描，在这些关建行看看除了系统的保留字是不是还有新的变量名，这里主要有这么几个难点：

- 我们要区分一个单词到底是变量名，还是数据类型名，还是函数名。

- 对于变量名我们保存下来，然后在下一轮“关建行勾选”的时候使用。

- 对于函数名我们其实可以不用理，要留就和变量名一起留，我们要在格式修正的部分多加一些东西，规定在括号的后面追加空格而不是回车，这样子保证函数和函数里面的形参在同一行，从而保证我们在保留了关键变量的同时，包含关键变量的同时，包含了关键变量的函数部分也会保留下来。

  ​

  我们在程序中设定一个状态：KEYLINE。当我们在Main函数中

配到一个回车的时候，我们就需要看看当前行号是不是关键行，如果是关键行，那我们就要进入KEYLINE状态。这个状态下我们需要我们找出新的关键变量。

​	这个过程中最难的就是如何分辨一个单词是变量还是函数还是数据类型。对于函数来说我们不管，一般情况下如果在一个单词后面紧接一个右括号，那么就只能说明这个是一个函数。数据类型也有比较明显的形式，主要发生在变量声明的时候，我们要匹配出这么几种格式。

`int a;`

`int *a;//星号的数量可以有多个。`

`int &b;`

`int a[];//大括号的数量可以有多个。但是除了最后一个之外里面都要有数。`

`int * a[];`

​	因为`*`和乘号很容易混，`&`和位运算符也很容易混，不过我们可以知道，数据类型，除了sizeof，只能出现在等号和分号的左边，不能出现在等号的右边和形参中。通过这种方式我们就可以直接把关键变量的间接相关变量得到，并且重新进入关建行扫描。二者反复，知道关建行不再增加为止。

